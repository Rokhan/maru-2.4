(load "pretty-print.l")

(define-function string-match-at (offset string comparand)
  (let ((lim (string-length comparand))
	(idx 0))
    (while (< idx lim)
      (or (= (string-at string (+ offset idx)) (string-at comparand idx))
	  (set idx lim))
      (incr idx))
    (= lim idx)))

(define-method do-print <array> ()
  (print "[")
  (for (i 0 (array-length self))
    (and (> i 0) (print " "))
    (print (array-at self i)))
  (print "]"))

(define-function string-copy (in . rest)
  (let* ((len   (string-length in))
	 (start (or (car  rest) 0))
	 (stop  (or (cadr rest) len)))
    (and (< stop 0) (incr stop len))
    (set stop (min len (max start stop)))
    (set len 0)
    (let ((out (string (- stop start))))
      (while (< start stop)
	(set (string-at out len) (string-at in start))
	(incr start)
	(incr len))
      out)))

(define-structure <parser>	(input position stack))

(define-structure <any>		())			(define-function any      ( ) (new <any>       ))
(define-structure <char>	(value))		(define-function char     (x) (new <char>     x))
(define-structure <class>	(value))		(define-function class    (x) (new <class>    x))
(define-structure <sequence>	(value length))		(define-function sequence (x) (new <sequence> x (string-length x)))
(define-structure <choice>	(alternate))		(define-function choice   (x) (new <choice>   x))
(define-structure <jump>	(destination))		(define-function jump     (x) (new <jump>     x))
(define-structure <call>	(destination))		(define-function call     (x) (new <call>     x))
(define-structure <commit>	(destination))		(define-function commit   (x) (new <commit>   x))
(define-structure <partial>	(destination))		(define-function partial  (x) (new <partial>  x))
(define-structure <fail>	())			(define-function fail     ( ) (new <fail>      ))
(define-structure <label>	(index))		(define-function label    (x) (new <label>    x))

(define-method do-print <char>	   ()	(print "<char     "(format "%c" self.value)">"))
(define-method do-print <class>	   ()	(print "<class    ") (dump self.value) (print ">"))
(define-method do-print <sequence> ()	(print "<sequence ") (dump self.value) (print ">"))
(define-method do-print <choice>   ()	(print "<choice   "self.alternate">"))
(define-method do-print <jump>	   ()	(print "<jump     "self.destination">"))
(define-method do-print <call>	   ()	(print "<call     "self.destination">"))
(define-method do-print <commit>   ()	(print "<commit   "self.destination">"))
(define-method do-print <partial>  ()	(print "<partial  "self.destination">"))

(define-form fail ()
  `(let ()
     (while (long? (set pc (pop sp))))
     (and (pair? pc) (let () (set ip (cdr pc)) (set pc (car pc))))))

(define-form succeed (npc)
  `(let ()
     (while (long? (set pc (pop sp))))
     (set pc ,npc)))

(define-function parse (input grammar)
  (let ((ep (string-length input)) (ip 0) (pc 0) (sp) (insn))
    (while (and (< ip ep) pc (set insn (array-at grammar pc)))
      (let* ((insn (array-at grammar pc))
	     (type (type-of insn)))
	;;(println (format "%04ld" pc)" "insn "\t"(format "%c" (string-at input ip))" "ip"@\""input"\"")
	(cond
	  ((= type <char>)	(if (= (string-at input ip) (<char>-value insn))
				    (let () (incr ip) (incr pc))
				  (fail)))
	  ((= type <class>)	(if (string-search (<class>-value insn) (string-at input ip))
				    (let () (incr ip) (incr pc))
				  (fail)))
	  ((= type <sequence>)	(if (string-match-at ip input (<sequence>-value insn))
				    (let () (incr ip (<sequence>-length insn)) (incr pc))
				  (fail)))
	  ((= type <choice>)	(push sp (cons (<choice>-alternate insn) ip))
				(incr pc))
	  ((= type <commit>)	(succeed (<commit>-destination insn)))
	  ((= type <partial>)	(set (cdr (car sp) ip))	;; update topmost backtrace input position
				(set pc (<partial>-destination insn)))
	  (else			(error "unknown instruction: "insn)))))
    (println pc" "ip)
    (if (or (= () pc) (array-at grammar pc))
	(println "NO MATCH")
      (println "matched "ip)
      (string-copy input 0 ip)
      )))

(define-structure <string-iterator> (string position))

(define-method at-end? <string-iterator> ()	(>= self.position (string-length self.string)))
(define-method rewind <string-iterator> (n)	(set self.position (- self.position n)) self)
(define-method context <string-iterator> ()	(string-copy self.string self.position (+ 32 self.position)))
(define-method peek <string-iterator> ()	(string-at self.string self.position))
(define-method next <string-iterator> ()	(let ((c (string-at self.string self.position)))
						  (incr self.position)
						  c))

(let ((n 0))
  (define-function new-label ()
    (incr n)))

(define-function array-with elements (list->array elements))

(define-function %array-flatten-all (in out)
  (if (array? in)
      (array-do elt in (%array-flatten-all elt out))
    (array-append out in)))

(define-function array-flatten-all (in)
  (let ((out (array)))
    (%array-flatten-all in out)
    out))

(define-function space? (c)	(and c (<= c ? )))

(define compile-pe-expression) ;; forward

(define-function compile-pe-space (in)
  (println "compile-pe-space "(format "'%c'"(peek in)))
  (while (space? (next in)))
  (rewind in 1))

(define-function compile-pe-class (in)
  (let ((c) (s (array)))
    (while (and (set c (next in)) (!= c ?\])) (array-append s c))
    (or c (error "missing ']' in character class"))
    (compile-pe-space in)
    (class (array->string (array-sort s)))))

(define-function compile-pe-string (in)
  (let ((c) (s (array)))
    (while (and (set c (next in)) (!= c ?\")) (array-append s c))
    (or c (error "missing '\"' in string"))
    (compile-pe-space in)
    (sequence (array->string s))))

(define-function compile-pe-primary (in)
  (println "compile-pe-primary "(peek in))
  (let ((c (next in)))
    (cond
      ((= c ?\[)	(compile-pe-class in))
      ((= c ?\")	(compile-pe-string in))
      ((= c ?\()	(let ((c ()) (p (array-with (compile-pe-expression in))))
			  (while (and (set c (next in)) (!= ?\) c))
			    (array-append p (compile-pe-expression in)))
			  (or (= ?\) c) (error "missing ')' near: "(context (rewind in 1))))
			  (compile-pe-space in)
			  p))
      ((= c ?\))	(rewind 1) ())
      (else		(error "primary expected near: "(context (rewind in 1)))))))

(define-function compile-pe-suffix (in)
  (println "compile-pe-suffix "(peek in))
  (let ((p (compile-pe-primary in)))
    (let ((c (next in)))
      (cond
	((= c ??)	(error "query"))
	((= c ?*)	(let ((l1 (new-label)) (l2 (new-label)))
			  (array-with (choice l2) (label l1) p (partial l1) (label l2))))
	((= c ?+)	(error "plus"))
	(else		(rewind in 1)
			p)))))

(define-function compile-pe-prefix (in)
  (println "compile-pe-prefix "(peek in))
  (let ((c (next in)))
    (cond
      ((= c ?!)	(error "not"))
      ((= c ?&)	(error "and"))
      (else	(rewind in 1)
		(compile-pe-suffix in)))))

(define-function compile-pe-sequence (in)
  (println "compile-pe-sequence "(peek in))
  (let ((c ()) (p (array)))
    (while (and (set c (peek in)) (!= ?\| c) (!= ?\) c))
      (array-append p (compile-pe-prefix in))
      (compile-pe-space in)
      )
    p))

(define-function compile-pe-expression (in)
  (println "compile-pe-expression "(peek in))
  (compile-pe-space in)
  (let ((p (array-with (compile-pe-sequence in))))
    (while (= ?\| (next in))
      (compile-pe-space in)
      (let ((l1 (new-label)) (l2 (new-label)))
	(set p (array-with (choice l1) p (commit l2) (label l1) (compile-pe-sequence in) (label l2)))
	))
    (rewind in 1)
    p))

(define-function resolve (in)
  (let ((labels (array))
	(out    (array)))
    (array-do insn in
      (cond
	((= (type-of insn) <label>)	(set (array-at labels (<label>-index insn)) (array-length out)))
	(else				(array-append out insn))))
    (array-do insn out
      (let ((type (type-of insn)))
	(cond
	  ((= type <choice>)	(set (<choice>-alternate    insn) (array-at labels (<choice>-alternate 	  insn))))
	  ((= type <jump>)	(set (<jump>-destination    insn) (array-at labels (<jump>-destination 	  insn))))
	  ((= type <call>)	(set (<call>-destination    insn) (array-at labels (<call>-destination 	  insn))))
	  ((= type <commit>)	(set (<commit>-destination  insn) (array-at labels (<commit>-destination  insn))))
	  ((= type <partial>)	(set (<partial>-destination insn) (array-at labels (<partial>-destination insn))))
	  ((= type <label>)	(error "this cannot happen")))))
    out))

(define-function compile-pe (string)
  (println "compile-pe")
  (let ((in  (new <string-iterator> string 0)))
    (let ((p (compile-pe-expression in)))
      (or (at-end? in) (error "error in PE near: "(context in)))
      (resolve (array-flatten-all p)))))

(let ((g (compile-pe "         ( \"hello\" | [abcdefghijklmnopqrstuvwxyz] | \",\" | [ ] | [()] ) * ")))
  (println)
  (for (i 0 (array-length g)) (println (format "%04i" i)" "(array-at g i)))
  (println)
  (println (parse "hello, (parsing) world." g)))
